<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>talloc: The talloc API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>The talloc API</h1>
<p>talloc is a hierarchical, reference counted memory pool system with destructors.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc__ref.html">The talloc reference function.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This module contains the definitions around talloc references. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc__array.html">The talloc array functions</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Talloc contains some handy helpers for handling Arrays conveniently. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc__string.html">The talloc string functions.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>talloc string allocation and manipulation functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc__debug.html">The talloc debugging support functions</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>To aid memory debugging, talloc contains routines to inspect the currently allocated memory hierarchy. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga2b3203a43d49423d064e1d889f6c584d">TALLOC_FREE</a>(ctx)&nbsp;&nbsp;&nbsp;do { talloc_free(ctx); ctx=NULL; } while(0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a talloc chunk and NULL out the pointer.  <a href="#ga2b3203a43d49423d064e1d889f6c584d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a talloc parent type.  <a href="#ga8a521b1347c0e37b84eb942db8fa9beb"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa">talloc</a> (const void *ctx,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new talloc context.  <a href="#ga69f0cbf5b2aed849a5b826f42e218bfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga1256d0dadd53ee54f7661a28cde11689">talloc_init</a> (const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new top level talloc context.  <a href="#ga1256d0dadd53ee54f7661a28cde11689"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86">talloc_free</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of talloc memory.  <a href="#ga3de117af6571f568866ec311bcd75f86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga939926bc6d0d87e1f223a993decb70e9">talloc_free_children</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a talloc chunk's children.  <a href="#ga939926bc6d0d87e1f223a993decb70e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga79d9cfea777a3d63167be7aa05463309">talloc_set_destructor</a> (const void *ptr, int(*destructor)(void *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a destructor function to be called when a chunk is freed.  <a href="#ga79d9cfea777a3d63167be7aa05463309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c">talloc_steal</a> (const void *new_ctx, const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a talloc chunk's parent.  <a href="#gaccc66139273e727183fb5bdda11ef82c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga4792242734944b8503d08fec937cc286">talloc_set_name</a> (const void *ptr, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a name to a talloc chunk.  <a href="#ga4792242734944b8503d08fec937cc286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga0f9da9eb976c6faef5fea2886b67fcda">talloc_move</a> (const void *new_ctx, void **pptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a talloc chunk's parent.  <a href="#ga0f9da9eb976c6faef5fea2886b67fcda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga204ed205d6b1524c46f12541d5eca686">talloc_set_name_const</a> (const void *ptr, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a name to a talloc chunk.  <a href="#ga204ed205d6b1524c46f12541d5eca686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaceeaddb8aa048f621a3bb9c7bfd44184">talloc_named</a> (const void *context, size_t size, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a named talloc chunk.  <a href="#gaceeaddb8aa048f621a3bb9c7bfd44184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gad6ad1f973c256a573566fdac671efc03">talloc_named_const</a> (const void *context, size_t size, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic routine to allocate a chunk of memory.  <a href="#gad6ad1f973c256a573566fdac671efc03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f">talloc_size</a> (const void *ctx, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Untyped allocation.  <a href="#ga7c67e6decbf19c39d95c5db277327c6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaaf0a56eb96eb840b8aae7c0f1bb10630">talloc_ptrtype</a> (const void *ctx,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate into a typed pointer.  <a href="#gaaf0a56eb96eb840b8aae7c0f1bb10630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaedc7467bff42fc3603f23dcd1d4a81f8">talloc_new</a> (const void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new 0-sized talloc chunk.  <a href="#gaedc7467bff42fc3603f23dcd1d4a81f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga59294157b625a15484f8960cf9440f95">talloc_zero</a> (const void *ctx,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a 0-initizialized structure.  <a href="#ga59294157b625a15484f8960cf9440f95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaa003b934f71a715e16bb05dff3431db2">talloc_zero_size</a> (const void *ctx, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate untyped, 0-initialized memory.  <a href="#gaa003b934f71a715e16bb05dff3431db2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga854bc4e030677deae1c68d10bb5de31a">talloc_get_name</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of a talloc chunk.  <a href="#ga854bc4e030677deae1c68d10bb5de31a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga1f4f10b2b41c13879fd30cdb30b50862">talloc_check_name</a> (const void *ptr, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verify that a talloc chunk carries a specified name.  <a href="#ga1f4f10b2b41c13879fd30cdb30b50862"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga75452866b0cd5c7d5a3a8e7c9dd7a6a5">talloc_parent</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parent chunk of a pointer.  <a href="#ga75452866b0cd5c7d5a3a8e7c9dd7a6a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga45aec19f076278e5ab25c860951e6ad6">talloc_parent_name</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a talloc chunk's parent name.  <a href="#ga45aec19f076278e5ab25c860951e6ad6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga7fdaffb5e7b6ec5ee2a2d94070074338">talloc_total_size</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the total size of a talloc chunk including its children.  <a href="#ga7fdaffb5e7b6ec5ee2a2d94070074338"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gabb6eba197e7e2cf57f7f7a5dce21b869">talloc_total_blocks</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of talloc chunks hanging off a chunk.  <a href="#gabb6eba197e7e2cf57f7f7a5dce21b869"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga97642c07748eb71e117284b7c3a8cf51">talloc_memdup</a> (const void *t, const void *p, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a memory area into a talloc chunk.  <a href="#ga97642c07748eb71e117284b7c3a8cf51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gabd4cfcf6487c70f14f4bea76e841ae85">talloc_set_type</a> (const char *ptr,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a type to a talloc chunk.  <a href="#gabd4cfcf6487c70f14f4bea76e841ae85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">type *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga1ee43e9ef59fc4edfce9a12b9cc54a63">talloc_get_type</a> (const void *ptr,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a typed pointer out of a talloc pointer.  <a href="#ga1ee43e9ef59fc4edfce9a12b9cc54a63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaa12adf71d94abc4e1d80fb951808e374">talloc_get_type_abort</a> (const void *ptr,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely turn a void pointer into a typed pointer.  <a href="#gaa12adf71d94abc4e1d80fb951808e374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaa5dee9fd4d8d4700f14ea4dd92cd4f14">talloc_find_parent_byname</a> (const void *ctx, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a parent context by name.  <a href="#gaa5dee9fd4d8d4700f14ea4dd92cd4f14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga568ede4c76275720b08d19011fc05f3a">talloc_find_parent_bytype</a> (const void *ptr,#type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a parent context by type.  <a href="#ga568ede4c76275720b08d19011fc05f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713">talloc_pool</a> (const void *context, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a talloc pool.  <a href="#ga454194769421483dbd512f26c622f713"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>talloc is a hierarchical, reference counted memory pool system with destructors. </p>
<p>It is the core memory allocator used in Samba. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga2b3203a43d49423d064e1d889f6c584d"></a><!-- doxytag: member="talloc.h::TALLOC_FREE" ref="ga2b3203a43d49423d064e1d889f6c584d" args="(ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TALLOC_FREE</td>
          <td>(</td>
          <td class="paramtype">ctx&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;do { talloc_free(ctx); ctx=NULL; } while(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a talloc chunk and NULL out the pointer. </p>
<p><a class="el" href="group__talloc.html#ga2b3203a43d49423d064e1d889f6c584d" title="Free a talloc chunk and NULL out the pointer.">TALLOC_FREE()</a> frees a pointer and sets it to NULL. Use this if you want immediate feedback (i.e. crash) if you use a pointer after having free'ed it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The chunk to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga8a521b1347c0e37b84eb942db8fa9beb"></a><!-- doxytag: member="talloc.h::TALLOC_CTX" ref="ga8a521b1347c0e37b84eb942db8fa9beb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define a talloc parent type. </p>
<p>As talloc is a hierarchial memory allocator, every talloc chunk is a potential parent to other talloc chunks. So defining a separate type for a talloc chunk is not strictly necessary. TALLOC_CTX is defined nevertheless, as it provides an indicator for function arguments. You will frequently write code like</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>foo *foo_create(<a class="code" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb" title="Define a talloc parent type.">TALLOC_CTX</a> *mem_ctx)
      {
              <span class="keyword">struct </span>foo *result;
              result = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(mem_ctx, <span class="keyword">struct</span> foo);
              <span class="keywordflow">if</span> (result == NULL) <span class="keywordflow">return</span> NULL;
                      ... initialize foo ...
              <span class="keywordflow">return</span> result;
      }
</pre></div><p>In this type of allocating functions it is handy to have a general TALLOC_CTX type to indicate which parent to put allocated structures on. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga69f0cbf5b2aed849a5b826f42e218bfa"></a><!-- doxytag: member="talloc.h::talloc" ref="ga69f0cbf5b2aed849a5b826f42e218bfa" args="(const void *ctx,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new talloc context. </p>
<p>The <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> macro is the core of the talloc library. It takes a memory context and a type, and returns a pointer to a new area of memory of the given type.</p>
<p>The returned pointer is itself a talloc context, so you can use it as the context argument to more calls to talloc if you wish.</p>
<p>The returned pointer is a "child" of the supplied context. This means that if you <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> the context then the new child disappears as well. Alternatively you can free just the child.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>A talloc context to create a new reference on or NULL to create a new top level context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type of memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A type casted talloc context or NULL on error.</dd></dl>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *a, *b;

      a = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(NULL, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
      b = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(a, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga59294157b625a15484f8960cf9440f95" title="Allocate a 0-initizialized structure.">talloc_zero</a> </dd>
<dd>
<a class="el" href="group__talloc__array.html#gac6efb2da7824d99a688196c4b45ca361" title="Allocate an array.">talloc_array</a> </dd>
<dd>
<a class="el" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c" title="Change a talloc chunk&#39;s parent.">talloc_steal</a> </dd>
<dd>
<a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f4f10b2b41c13879fd30cdb30b50862"></a><!-- doxytag: member="talloc.h::talloc_check_name" ref="ga1f4f10b2b41c13879fd30cdb30b50862" args="(const void *ptr, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_check_name </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify that a talloc chunk carries a specified name. </p>
<p>This function checks if a pointer has the specified name. If it does then the pointer is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to check.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name to check against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer if the name matches, NULL if it doesn't. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5dee9fd4d8d4700f14ea4dd92cd4f14"></a><!-- doxytag: member="talloc.h::talloc_find_parent_byname" ref="gaa5dee9fd4d8d4700f14ea4dd92cd4f14" args="(const void *ctx, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_find_parent_byname </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a parent context by name. </p>
<p>Find a parent memory context of the current context that has the given name. This can be very useful in complex programs where it may be difficult to pass all information down to the level you need, but you know the structure you want is a parent of another context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The talloc chunk to start from.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the parent we look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The memory context we are looking for, NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga568ede4c76275720b08d19011fc05f3a"></a><!-- doxytag: member="talloc.h::talloc_find_parent_bytype" ref="ga568ede4c76275720b08d19011fc05f3a" args="(const void *ptr,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_find_parent_bytype </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a parent context by type. </p>
<p>Find a parent memory context of the current context that has the given name. This can be very useful in complex programs where it may be difficult to pass all information down to the level you need, but you know the structure you want is a parent of another context.</p>
<p>Like <a class="el" href="group__talloc.html#gaa5dee9fd4d8d4700f14ea4dd92cd4f14" title="Find a parent context by name.">talloc_find_parent_byname()</a> but takes a type, making it typesafe.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to start from.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type of the parent to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The memory context we are looking for, NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3de117af6571f568866ec311bcd75f86"></a><!-- doxytag: member="talloc.h::talloc_free" ref="ga3de117af6571f568866ec311bcd75f86" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int talloc_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a chunk of talloc memory. </p>
<p>The <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> function frees a piece of talloc memory, and all its children. You can call <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> on any pointer returned by <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a>.</p>
<p>The return value of <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> indicates success or failure, with 0 returned for success and -1 for failure. A possible failure condition is if the pointer had a destructor attached to it and the destructor returned -1. See <a class="el" href="group__talloc.html#ga79d9cfea777a3d63167be7aa05463309" title="Assign a destructor function to be called when a chunk is freed.">talloc_set_destructor()</a> for details on destructors. Likewise, if "ptr" is NULL, then the function will make no modifications and return -1.</p>
<p>From version 2.0 and onwards, as a special case, <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> is refused on pointers that have more than one parent associated, as talloc would have no way of knowing which parent should be removed. This is different from older versions in the sense that always the reference to the most recently established parent has been destroyed. Hence to free a pointer that has more than one parent please use <a class="el" href="group__talloc__ref.html#ga8054dd3561f33dd4a0d6942839868bb5" title="Remove a specific parent from a talloc chunk.">talloc_unlink()</a>.</p>
<p>To help you find problems in your code caused by this behaviour, if you do try and free a pointer with more than one parent then the talloc logging function will be called to give output like this:</p>
<div class="fragment"><pre class="fragment">   ERROR: <a class="code" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free</a> with references at some_dir/source/foo.c:123
     reference at some_dir/source/other.c:325
     reference at some_dir/source/third.c:121
</pre></div><p>Please see the documentation for <a class="el" href="group__talloc__debug.html#ga5694661cc56931d6edfd926043e43cce" title="Set a logging function.">talloc_set_log_fn()</a> and <a class="el" href="group__talloc__debug.html#ga28b5f73a0dc144abc1c4a231d2d2842f" title="Set stderr as the output for logs.">talloc_set_log_stderr()</a> for more information on talloc logging functions.</p>
<p>If <code>TALLOC_FREE_FILL</code> environment variable is set, the memory occupied by the context is filled with the value of this variable. The value should be a numeric representation of the character you want to use.</p>
<p><a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> operates recursively on its children.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The chunk to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success and -1 on error. A possible failure condition is if the pointer had a destructor attached to it and the destructor returned -1. Likewise, if "ptr" is NULL, then the function will make no modifications and returns -1.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *a, *b;
      a = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(NULL, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
      b = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(a, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);

      <a class="code" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free</a>(a); <span class="comment">// Frees a and b</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga79d9cfea777a3d63167be7aa05463309" title="Assign a destructor function to be called when a chunk is freed.">talloc_set_destructor()</a> </dd>
<dd>
<a class="el" href="group__talloc__ref.html#ga8054dd3561f33dd4a0d6942839868bb5" title="Remove a specific parent from a talloc chunk.">talloc_unlink()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga939926bc6d0d87e1f223a993decb70e9"></a><!-- doxytag: member="talloc.h::talloc_free_children" ref="ga939926bc6d0d87e1f223a993decb70e9" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void talloc_free_children </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a talloc chunk's children. </p>
<p>The function walks along the list of all children of a talloc context and <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a>s only the children, not the context itself.</p>
<p>A NULL argument is handled as no-op.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The chunk that you want to free the children of (NULL is allowed too) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga854bc4e030677deae1c68d10bb5de31a"></a><!-- doxytag: member="talloc.h::talloc_get_name" ref="ga854bc4e030677deae1c68d10bb5de31a" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* talloc_get_name </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the name of a talloc chunk. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current name for the given talloc pointer.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga4792242734944b8503d08fec937cc286" title="Assign a name to a talloc chunk.">talloc_set_name()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ee43e9ef59fc4edfce9a12b9cc54a63"></a><!-- doxytag: member="talloc.h::talloc_get_type" ref="ga1ee43e9ef59fc4edfce9a12b9cc54a63" args="(const void *ptr,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type* talloc_get_type </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a typed pointer out of a talloc pointer. </p>
<p>This macro allows you to do type checking on talloc pointers. It is particularly useful for void* private pointers. It is equivalent to this:</p>
<div class="fragment"><pre class="fragment">      (type *)<a class="code" href="group__talloc.html#ga1f4f10b2b41c13879fd30cdb30b50862" title="Verify that a talloc chunk carries a specified name.">talloc_check_name</a>(ptr, #type)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc pointer to check.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type to check against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The properly casted pointer given by ptr, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa12adf71d94abc4e1d80fb951808e374"></a><!-- doxytag: member="talloc.h::talloc_get_type_abort" ref="gaa12adf71d94abc4e1d80fb951808e374" args="(const void *ptr,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_get_type_abort </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely turn a void pointer into a typed pointer. </p>
<p>This macro is used together with talloc(mem_ctx, struct foo). If you had to assing the talloc chunk pointer to some void pointer variable, <a class="el" href="group__talloc.html#gaa12adf71d94abc4e1d80fb951808e374" title="Safely turn a void pointer into a typed pointer.">talloc_get_type_abort()</a> is the recommended way to get the convert the void pointer back to a typed pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The void pointer to convert.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type that this chunk contains</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The same value as ptr, type-checked and properly cast. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1256d0dadd53ee54f7661a28cde11689"></a><!-- doxytag: member="talloc.h::talloc_init" ref="ga1256d0dadd53ee54f7661a28cde11689" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_init </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new top level talloc context. </p>
<p>This function creates a zero length named talloc context as a top level context. It is equivalent to:</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__talloc.html#gaceeaddb8aa048f621a3bb9c7bfd44184" title="Create a named talloc chunk.">talloc_named</a>(NULL, 0, fmt, ...);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fmt</em>&nbsp;</td><td>Format string for the name.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td>Additional printf-style arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory chunk, NULL on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#gaceeaddb8aa048f621a3bb9c7bfd44184" title="Create a named talloc chunk.">talloc_named()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga97642c07748eb71e117284b7c3a8cf51"></a><!-- doxytag: member="talloc.h::talloc_memdup" ref="ga97642c07748eb71e117284b7c3a8cf51" args="(const void *t, const void *p, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_memdup </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a memory area into a talloc chunk. </p>
<p>The function is equivalent to:</p>
<div class="fragment"><pre class="fragment">      ptr = <a class="code" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f" title="Untyped allocation.">talloc_size</a>(ctx, size);
      <span class="keywordflow">if</span> (ptr) memcpy(ptr, p, size);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>t</em>&nbsp;</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>The memory chunk you want to duplicate.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Number of char's that you want copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory chunk.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f" title="Untyped allocation.">talloc_size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f9da9eb976c6faef5fea2886b67fcda"></a><!-- doxytag: member="talloc.h::talloc_move" ref="ga0f9da9eb976c6faef5fea2886b67fcda" args="(const void *new_ctx, void **pptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_move </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>new_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>pptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a talloc chunk's parent. </p>
<p>This function has the same effect as <a class="el" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c" title="Change a talloc chunk&#39;s parent.">talloc_steal()</a>, and additionally sets the source pointer to NULL. You would use it like this:</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>foo *X = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(tmp_ctx, <span class="keyword">struct</span> foo);
      <span class="keyword">struct </span>foo *Y;
      Y = <a class="code" href="group__talloc.html#ga0f9da9eb976c6faef5fea2886b67fcda" title="Change a talloc chunk&amp;#39;s parent.">talloc_move</a>(new_ctx, &amp;X);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>new_ctx</em>&nbsp;</td><td>The new parent context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pptr</em>&nbsp;</td><td>Pointer to the talloc chunk to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer of the talloc chunk it has been moved to, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaceeaddb8aa048f621a3bb9c7bfd44184"></a><!-- doxytag: member="talloc.h::talloc_named" ref="gaceeaddb8aa048f621a3bb9c7bfd44184" args="(const void *context, size_t size, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_named </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a named talloc chunk. </p>
<p>The <a class="el" href="group__talloc.html#gaceeaddb8aa048f621a3bb9c7bfd44184" title="Create a named talloc chunk.">talloc_named()</a> function creates a named talloc pointer. It is equivalent to:</p>
<div class="fragment"><pre class="fragment">      ptr = <a class="code" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f" title="Untyped allocation.">talloc_size</a>(context, size);
      <a class="code" href="group__talloc.html#ga4792242734944b8503d08fec937cc286" title="Assign a name to a talloc chunk.">talloc_set_name</a>(ptr, fmt, ....);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Number of char's that you want to allocate.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fmt</em>&nbsp;</td><td>Format string for the name.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td>Additional printf-style arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory chunk, NULL on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga4792242734944b8503d08fec937cc286" title="Assign a name to a talloc chunk.">talloc_set_name()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad6ad1f973c256a573566fdac671efc03"></a><!-- doxytag: member="talloc.h::talloc_named_const" ref="gad6ad1f973c256a573566fdac671efc03" args="(const void *context, size_t size, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_named_const </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic routine to allocate a chunk of memory. </p>
<p>This is equivalent to:</p>
<div class="fragment"><pre class="fragment">      ptr = <a class="code" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f" title="Untyped allocation.">talloc_size</a>(context, size);
      <a class="code" href="group__talloc.html#ga204ed205d6b1524c46f12541d5eca686" title="Assign a name to a talloc chunk.">talloc_set_name_const</a>(ptr, name);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The parent context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>The number of char's that we want to allocate.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name the talloc block has.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory chunk, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaedc7467bff42fc3603f23dcd1d4a81f8"></a><!-- doxytag: member="talloc.h::talloc_new" ref="gaedc7467bff42fc3603f23dcd1d4a81f8" args="(const void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_new </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new 0-sized talloc chunk. </p>
<p>This is a utility macro that creates a new memory context hanging off an existing context, automatically naming it "talloc_new: __location__" where __location__ is the source line it is called from. It is particularly useful for creating a new temporary working context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The talloc parent context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new talloc chunk, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75452866b0cd5c7d5a3a8e7c9dd7a6a5"></a><!-- doxytag: member="talloc.h::talloc_parent" ref="ga75452866b0cd5c7d5a3a8e7c9dd7a6a5" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_parent </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the parent chunk of a pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc pointer to inspect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The talloc parent of ptr, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45aec19f076278e5ab25c860951e6ad6"></a><!-- doxytag: member="talloc.h::talloc_parent_name" ref="ga45aec19f076278e5ab25c860951e6ad6" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* talloc_parent_name </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a talloc chunk's parent name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc pointer to inspect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of ptr's parent chunk. </dd></dl>

</div>
</div>
<a class="anchor" id="ga454194769421483dbd512f26c622f713"></a><!-- doxytag: member="talloc.h::talloc_pool" ref="ga454194769421483dbd512f26c622f713" args="(const void *context, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_pool </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a talloc pool. </p>
<p>A talloc pool is a pure optimization for specific situations. In the release process for Samba 3.2 we found out that we had become considerably slower than Samba 3.0 was. Profiling showed that malloc(3) was a large CPU consumer in benchmarks. For Samba 3.2 we have internally converted many static buffers to dynamically allocated ones, so malloc(3) being beaten more was no surprise. But it made us slower.</p>
<p><a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713" title="Allocate a talloc pool.">talloc_pool()</a> is an optimization to call malloc(3) a lot less for the use pattern Samba has: The SMB protocol is mainly a request/response protocol where we have to allocate a certain amount of memory per request and free that after the SMB reply is sent to the client.</p>
<p><a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713" title="Allocate a talloc pool.">talloc_pool()</a> creates a talloc chunk that you can use as a talloc parent exactly as you would use any other <a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb" title="Define a talloc parent type.">TALLOC_CTX</a>. The difference is that when you talloc a child of this pool, no malloc(3) is done. Instead, talloc just increments a pointer inside the talloc_pool. This also works recursively. If you use the child of the talloc pool as a parent for grand-children, their memory is also taken from the talloc pool.</p>
<p>If there is not enough memory in the pool to allocate the new child, it will create a new talloc chunk as if the parent was a normal talloc context.</p>
<p>If you <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> children of a talloc pool, the memory is not given back to the system. Instead, free(3) is only called if the <a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713" title="Allocate a talloc pool.">talloc_pool()</a> itself is released with <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a>.</p>
<p>The downside of a talloc pool is that if you <a class="el" href="group__talloc.html#ga0f9da9eb976c6faef5fea2886b67fcda" title="Change a talloc chunk&#39;s parent.">talloc_move()</a> a child of a talloc pool to a talloc parent outside the pool, the whole pool memory is not free(3)'ed until that moved chunk is also <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a>ed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The talloc context to hang the result off (must not be another pool).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the talloc pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated talloc pool, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf0a56eb96eb840b8aae7c0f1bb10630"></a><!-- doxytag: member="talloc.h::talloc_ptrtype" ref="gaaf0a56eb96eb840b8aae7c0f1bb10630" args="(const void *ctx,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_ptrtype </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate into a typed pointer. </p>
<p>The <a class="el" href="group__talloc.html#gaaf0a56eb96eb840b8aae7c0f1bb10630" title="Allocate into a typed pointer.">talloc_ptrtype()</a> macro should be used when you have a pointer and want to allocate memory to point at with this pointer. When compiling with gcc &gt;= 3 it is typesafe. Note this is a wrapper of <a class="el" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f" title="Untyped allocation.">talloc_size()</a> and <a class="el" href="group__talloc.html#ga854bc4e030677deae1c68d10bb5de31a" title="Return the name of a talloc chunk.">talloc_get_name()</a> will return the current location in the source file and not the type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The pointer you want to assign the result to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The properly casted allocated memory chunk, NULL on error.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *a = <a class="code" href="group__talloc.html#gaaf0a56eb96eb840b8aae7c0f1bb10630" title="Allocate into a typed pointer.">talloc_ptrtype</a>(NULL, a);
</pre></div> 
</div>
</div>
<a class="anchor" id="ga79d9cfea777a3d63167be7aa05463309"></a><!-- doxytag: member="talloc.h::talloc_set_destructor" ref="ga79d9cfea777a3d63167be7aa05463309" args="(const void *ptr, int(*destructor)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void talloc_set_destructor </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a destructor function to be called when a chunk is freed. </p>
<p>The function <a class="el" href="group__talloc.html#ga79d9cfea777a3d63167be7aa05463309" title="Assign a destructor function to be called when a chunk is freed.">talloc_set_destructor()</a> sets the "destructor" for the pointer "ptr". A destructor is a function that is called when the memory used by a pointer is about to be released. The destructor receives the pointer as an argument, and should return 0 for success and -1 for failure.</p>
<p>The destructor can do anything it wants to, including freeing other pieces of memory. A common use for destructors is to clean up operating system resources (such as open file descriptors) contained in the structure the destructor is placed on.</p>
<p>You can only place one destructor on a pointer. If you need more than one destructor then you can create a zero-length child of the pointer and place an additional destructor on that.</p>
<p>To remove a destructor call <a class="el" href="group__talloc.html#ga79d9cfea777a3d63167be7aa05463309" title="Assign a destructor function to be called when a chunk is freed.">talloc_set_destructor()</a> with NULL for the destructor.</p>
<p>If your destructor attempts to <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> the pointer that it is the destructor for then <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> will return -1 and the free will be ignored. This would be a pointless operation anyway, as the destructor is only called when the memory is just about to go away.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to add a destructor to.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>destructor</em>&nbsp;</td><td>The destructor function to be called. NULL to remove it.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">      <span class="keyword">static</span> <span class="keywordtype">int</span> destroy_fd(<span class="keywordtype">int</span> *fd) {
              close(*fd);
              <span class="keywordflow">return</span> 0;
      }

      <span class="keywordtype">int</span> *open_file(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename) {
              <span class="keywordtype">int</span> *fd = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(NULL, <span class="keywordtype">int</span>);
              *fd = open(filename, O_RDONLY);
              <span class="keywordflow">if</span> (*fd &lt; 0) {
                      <a class="code" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free</a>(fd);
                      <span class="keywordflow">return</span> NULL;
              }
              <span class="comment">// Whenever they free this, we close the file.</span>
              <a class="code" href="group__talloc.html#ga79d9cfea777a3d63167be7aa05463309" title="Assign a destructor function to be called when a chunk is freed.">talloc_set_destructor</a>(fd, destroy_fd);
              <span class="keywordflow">return</span> fd;
      }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> </dd>
<dd>
<a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4792242734944b8503d08fec937cc286"></a><!-- doxytag: member="talloc.h::talloc_set_name" ref="ga4792242734944b8503d08fec937cc286" args="(const void *ptr, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* talloc_set_name </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a name to a talloc chunk. </p>
<p>Each talloc pointer has a "name". The name is used principally for debugging purposes, although it is also possible to set and get the name on a pointer in as a way of "marking" pointers in your code.</p>
<p>The main use for names on pointer is for "talloc reports". See <a class="el" href="group__talloc__debug.html#ga4f4ff95ce5a95f61cc453fc943e3de65" title="Print a summary report of all memory used by ptr.">talloc_report()</a> and <a class="el" href="group__talloc__debug.html#ga66136eb6105416bfcbd390ce6a4fc89c" title="Print a summary report of all memory used by ptr.">talloc_report_full()</a> for details. Also see <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits.">talloc_enable_leak_report()</a> and <a class="el" href="group__talloc__debug.html#gab01ab00014902d25e9eaba9fd172821c" title="Enable full leak report when a program exits.">talloc_enable_leak_report_full()</a>.</p>
<p>The <a class="el" href="group__talloc.html#ga4792242734944b8503d08fec937cc286" title="Assign a name to a talloc chunk.">talloc_set_name()</a> function allocates memory as a child of the pointer. It is logically equivalent to:</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__talloc.html#ga204ed205d6b1524c46f12541d5eca686" title="Assign a name to a talloc chunk.">talloc_set_name_const</a>(ptr, <a class="code" href="group__talloc__string.html#ga91c7fe3bf2110cbb91eed6d9def4e4cc" title="Format a string.">talloc_asprintf</a>(ptr, fmt, ...));
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to assign a name to.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fmt</em>&nbsp;</td><td>Format string for the name.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td>Add printf-style additional arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The assigned name, NULL on error.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Multiple calls to <a class="el" href="group__talloc.html#ga4792242734944b8503d08fec937cc286" title="Assign a name to a talloc chunk.">talloc_set_name()</a> will allocate more memory without releasing the name. All of the memory is released when the ptr is freed using <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga204ed205d6b1524c46f12541d5eca686"></a><!-- doxytag: member="talloc.h::talloc_set_name_const" ref="ga204ed205d6b1524c46f12541d5eca686" args="(const void *ptr, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void talloc_set_name_const </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a name to a talloc chunk. </p>
<p>The function is just like <a class="el" href="group__talloc.html#ga4792242734944b8503d08fec937cc286" title="Assign a name to a talloc chunk.">talloc_set_name()</a>, but it takes a string constant, and is much faster. It is extensively used by the "auto naming" macros, such as talloc_p().</p>
<p>This function does not allocate any memory. It just copies the supplied pointer into the internal representation of the talloc ptr. This means you must not pass a name pointer to memory that will disappear before the ptr is freed with <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to assign a name to.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Format string for the name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd4cfcf6487c70f14f4bea76e841ae85"></a><!-- doxytag: member="talloc.h::talloc_set_type" ref="gabd4cfcf6487c70f14f4bea76e841ae85" args="(const char *ptr,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void talloc_set_type </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a type to a talloc chunk. </p>
<p>This macro allows you to force the name of a pointer to be of a particular type. This can be used in conjunction with <a class="el" href="group__talloc.html#ga1ee43e9ef59fc4edfce9a12b9cc54a63" title="Get a typed pointer out of a talloc pointer.">talloc_get_type()</a> to do type checking on void* pointers.</p>
<p>It is equivalent to this:</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__talloc.html#ga204ed205d6b1524c46f12541d5eca686" title="Assign a name to a talloc chunk.">talloc_set_name_const</a>(ptr, #type)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to assign the type to.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c67e6decbf19c39d95c5db277327c6f"></a><!-- doxytag: member="talloc.h::talloc_size" ref="ga7c67e6decbf19c39d95c5db277327c6f" args="(const void *ctx, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_size </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Untyped allocation. </p>
<p>The function should be used when you don't have a convenient type to pass to <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a>. Unlike <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a>, it is not type safe (as it returns a void *), so you are on your own for type checking.</p>
<p>Best to use <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> or <a class="el" href="group__talloc__array.html#gac6efb2da7824d99a688196c4b45ca361" title="Allocate an array.">talloc_array()</a> instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Number of char's that you want to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory chunk, NULL on error.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> *mem = <a class="code" href="group__talloc.html#ga7c67e6decbf19c39d95c5db277327c6f" title="Untyped allocation.">talloc_size</a>(NULL, 100);
</pre></div> 
</div>
</div>
<a class="anchor" id="gaccc66139273e727183fb5bdda11ef82c"></a><!-- doxytag: member="talloc.h::talloc_steal" ref="gaccc66139273e727183fb5bdda11ef82c" args="(const void *new_ctx, const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_steal </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>new_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a talloc chunk's parent. </p>
<p>The <a class="el" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c" title="Change a talloc chunk&#39;s parent.">talloc_steal()</a> function changes the parent context of a talloc pointer. It is typically used when the context that the pointer is currently a child of is going to be freed and you wish to keep the memory for a longer time.</p>
<p>To make the changed hierarchy less error-prone, you might consider to use <a class="el" href="group__talloc.html#ga0f9da9eb976c6faef5fea2886b67fcda" title="Change a talloc chunk&#39;s parent.">talloc_move()</a>.</p>
<p>If you try and call <a class="el" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c" title="Change a talloc chunk&#39;s parent.">talloc_steal()</a> on a pointer that has more than one parent then the result is ambiguous. Talloc will choose to remove the parent that is currently indicated by <a class="el" href="group__talloc.html#ga75452866b0cd5c7d5a3a8e7c9dd7a6a5" title="Get the parent chunk of a pointer.">talloc_parent()</a> and replace it with the chosen parent. You will also get a message like this via the talloc logging functions:</p>
<div class="fragment"><pre class="fragment">   WARNING: <a class="code" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c" title="Change a talloc chunk&amp;#39;s parent.">talloc_steal</a> with references at some_dir/source/foo.c:123
     reference at some_dir/source/other.c:325
     reference at some_dir/source/third.c:121
</pre></div><p>To unambiguously change the parent of a pointer please see the function <a class="el" href="group__talloc__ref.html#gad08d78c3987437a5753efc55379f0566" title="Change the parent context of a talloc pointer.">talloc_reparent()</a>. See the <a class="el" href="group__talloc__debug.html#ga5694661cc56931d6edfd926043e43cce" title="Set a logging function.">talloc_set_log_fn()</a> documentation for more information on talloc logging.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>new_ctx</em>&nbsp;</td><td>The new parent context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the pointer that you pass it. It does not have any failure modes.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is possible to produce loops in the parent/child relationship if you are not careful with <a class="el" href="group__talloc.html#gaccc66139273e727183fb5bdda11ef82c" title="Change a talloc chunk&#39;s parent.">talloc_steal()</a>. No guarantees are provided as to your sanity or the safety of your data if you do this. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb6eba197e7e2cf57f7f7a5dce21b869"></a><!-- doxytag: member="talloc.h::talloc_total_blocks" ref="gabb6eba197e7e2cf57f7f7a5dce21b869" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t talloc_total_blocks </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of talloc chunks hanging off a chunk. </p>
<p>The <a class="el" href="group__talloc.html#gabb6eba197e7e2cf57f7f7a5dce21b869" title="Get the number of talloc chunks hanging off a chunk.">talloc_total_blocks()</a> function returns the total memory block count used by this pointer and all child pointers. Mostly useful for debugging.</p>
<p>Passing NULL is allowed, but it will only give a meaningful result if <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits.">talloc_enable_leak_report()</a> or <a class="el" href="group__talloc__debug.html#gab01ab00014902d25e9eaba9fd172821c" title="Enable full leak report when a program exits.">talloc_enable_leak_report_full()</a> has been called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total size. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fdaffb5e7b6ec5ee2a2d94070074338"></a><!-- doxytag: member="talloc.h::talloc_total_size" ref="ga7fdaffb5e7b6ec5ee2a2d94070074338" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t talloc_total_size </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total size of a talloc chunk including its children. </p>
<p>The function returns the total size in bytes used by this pointer and all child pointers. Mostly useful for debugging.</p>
<p>Passing NULL is allowed, but it will only give a meaningful result if <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits.">talloc_enable_leak_report()</a> or <a class="el" href="group__talloc__debug.html#gab01ab00014902d25e9eaba9fd172821c" title="Enable full leak report when a program exits.">talloc_enable_leak_report_full()</a> has been called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>The talloc chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total size. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59294157b625a15484f8960cf9440f95"></a><!-- doxytag: member="talloc.h::talloc_zero" ref="ga59294157b625a15484f8960cf9440f95" args="(const void *ctx,#type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_zero </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">#&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a 0-initizialized structure. </p>
<p>The macro is equivalent to:</p>
<div class="fragment"><pre class="fragment">      ptr = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(ctx, type);
      <span class="keywordflow">if</span> (ptr) memset(ptr, 0, <span class="keyword">sizeof</span>(type));
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type that we want to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a piece of memory, properly cast to 'type *', NULL on error.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *a, *b;
      a = <a class="code" href="group__talloc.html#ga59294157b625a15484f8960cf9440f95" title="Allocate a 0-initizialized structure.">talloc_zero</a>(NULL, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
      b = <a class="code" href="group__talloc.html#ga59294157b625a15484f8960cf9440f95" title="Allocate a 0-initizialized structure.">talloc_zero</a>(a, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> </dd>
<dd>
<a class="el" href="group__talloc.html#gaa003b934f71a715e16bb05dff3431db2" title="Allocate untyped, 0-initialized memory.">talloc_zero_size()</a> </dd>
<dd>
<a class="el" href="group__talloc__array.html#ga829553410db85b23f5e4e4a7f1b98c11" title="Allocate a zero-initialized array.">talloc_zero_array()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa003b934f71a715e16bb05dff3431db2"></a><!-- doxytag: member="talloc.h::talloc_zero_size" ref="gaa003b934f71a715e16bb05dff3431db2" args="(const void *ctx, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_zero_size </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate untyped, 0-initialized memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Number of char's that you want to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory chunk. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
