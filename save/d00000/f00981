<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
                 <link rel="shortcut icon" href="/tnf/resource/favicon.ico" type="image/x-icon"> 
		<title>
			NetBSD Blog
		</title>
                <link rel="stylesheet" type="text/css" href='/tnf/resource/global.css' />
		<link rel="stylesheet" type="text/css" href='/tnf/page/custom.css' />
	</head>
	<body>
		
			        
            <link rel="alternate" type="application/atom+xml" title="Recent Entries (Atom)"  href="http://blog.netbsd.org/tnf/feed/entries/atom" />
    <link rel="alternate" type="application/rss+xml"  title="Recent Entries (RSS)"   href="http://blog.netbsd.org/tnf/feed/entries/rss" />
    <link rel="alternate" type="application/atom+xml" title="Recent Comments (Atom)" href="http://blog.netbsd.org/tnf/feed/comments/atom" />
    <link rel="alternate" type="application/rss+xml"  title="Recent Comments (RSS)"  href="http://blog.netbsd.org/tnf/feed/comments/rss" />

          <link rel="alternate" type="application/atom+xml" title="Entries for category General (Atom)"  href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FGeneral" />
      <link rel="alternate" type="application/rss+xml"  title="Entries for category General (RSS)"   href="http://blog.netbsd.org/tnf/feed/entries/rss?cat=%2FGeneral" />
    
                <link rel="search"
            title="OpenSearch Descriptor for weblog NetBSD Blog"
            type="application/opensearchdescription+xml"
            href="http://blog.netbsd.org/roller-services/opensearch/tnf" />
    		
		<div id="header">
			<div class="topNavigation">
				<span>&raquo;</span> <a href="http://www.NetBSD.org/docs/guide/en/">The Guide</a> | <a href="http://man.NetBSD.org">Manual pages</a> | <a href="http://www.NetBSD.org/mailinglists/">Mailing lists</a> and <a href="http://mail-index.NetBSD.org/">Archives</a> | <a href="http://cvsweb.NetBSD.org/">CVS repository</a> | <a href="http://www.NetBSD.org/cgi-bin/sendpr.cgi?gndb=netbsd">Report</a> or <a href="http://gnats.NetBSD.org/">query</a> a bug | <a href="http://www.NetBSD.org/docs/software/packages.html">Software Packages</a>
			</div>
			<div class="centralHeader">
				<a href="/"><img src="/tnf/resource/NetBSD-headerlogo.png" alt="[NetBSD Logo]" width="506" height="90" /></a>
				<div class="headerTools">
<BR>
					<div id="headerSearch">
						<form method="get" action="/tnf/search">
							<input class="whiteOnBlack" type="text" name="q" onfocus="if(this.value==this.defaultValue ) this.value='';" size="12" maxlength="255" value="Search" /> <input type="submit" value="Search" />
						</form>
					</div>
				</div>
			</div>
			<div class="navBar">
				<a href="http://blog.netbsd.org/tnf/" title="Home">Home</a>&nbsp;|&nbsp;
                                <img src="/tnf/resource/feed-icon-14x14.png" border=0 align="absmiddle"><a href="http://blog.netbsd.org/tnf/feed/entries/atom">RSS</a>&nbsp;|&nbsp;
 <a href="http://blog.netbsd.org/tnf/category/General" title="General">General</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Release+engineering" title="Blog about NetBSD release engineering.">Release engineering</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Networking" title="">Networking</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Development" title="About NetBSD development.">Development</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Events" title="Upcoming and past events.">Events</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/The+NetBSD+Foundation" title="TNF articles.">The NetBSD Foundation</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Packages" title="The most portable package software in the world.">Packages</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Security" title="Security advisories and security related information.">Security</a>&nbsp;|&nbsp;  <a href="http://blog.netbsd.org/tnf/category/Ports" title="Port specific news">Ports</a>&nbsp;|&nbsp; 
      <a href="/roller-ui/login-redirect.rol"><span>Login</span></a>
  			</div>
		</div>
		<div id="content">
			<div class="rowOfBoxes">
				<div class="quarter noBorderOnLeft borderOnRight sideBarLeft">

                                                <h3>Bookmarks</h3>
                                                                                                <ul class="rFolder">
                    <li class="rFolderItem">
                                <a href="http://www.NetBSD.org/"
               title="NetBSD is a free, secure, and highly portable Unix-like Open Source operating system available for many platforms, from large-scale server systems to powerful desktop systems to handheld and embedded devices."
               class="rBookmark0">The NetBSD Project</a>
                </li>
            <li class="rFolderItem">
                                <a href="http://wiki.netbsd.org/"
               title="The NetBSD Wiki is a collaborative writing project to build useful resources for NetBSD users."
               class="rBookmark0">NetBSD Wiki</a>
                </li>
                    </ul>
	
						<h3>Feeds</h3>
						    <ul class="rFeeds">
    <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom">All</a></li>
                <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FGeneral">/General</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FRelease+engineering">/Release engineering</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FNetworking">/Networking</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FDevelopment">/Development</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FEvents">/Events</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FThe+NetBSD+Foundation">/The NetBSD Foundation</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FPackages">/Packages</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FSecurity">/Security</a></li>
            <li><a href="http://blog.netbsd.org/tnf/feed/entries/atom?cat=%2FPorts">/Ports</a></li>
        <li><a href="http://blog.netbsd.org/tnf/feed/comments/atom">Comments</a></li>
    </ul>

			</div>
			</div>
			<div class="mainContent">
				<div class="half noBorderOnLeft" style="border-left: 1px dotted #000">
							  		              <h2><a href="http://blog.netbsd.org/tnf/entry/google_code_in_2012_2013">Google Code-In 2012/2013 (from jdf)</a></h2><BR>
<div class="descr">July 02, 2013 posted by <i>Matthew Sporleder</I></div><BR>

  <p>
Google Code-In (GCi) is a project like Google Summer Of Code (GSoC),
but for younger students. While GSoC is aimed at university students,
i.e. for people usually of age 19 or older, GCi wants to recruit
pupils for Open Source projects.
</p>
<p>
When applying for participation, every project had to create a large number of 
potentially small tasks for students. A task was meant to be two hours of work of 
an experienced developer, and feasible to be done by a person 13 to 18 years 
old. Google selected ten participating organisations (this time, NetBSD 
was the only BSD participating) to insert their tasks into Google Melange (the 
platform which is used for managing GCi and GSoC).
</p>
<p>
Then, the students registered at Google Melange, chose a project they wanted to 
work on, and claimed tasks to do. There were many chats in the NetBSD code 
channel for students coming in and asking questions about their tasks.
</p>
<p>
After GCi was over, every organisation had to choose their two favourite 
students who did the best work. For NetBSD, the choice was difficult, as there 
were more than two students doing great work, but in the end we chose Mingzhe 
Wang and Matthew Bauer.
These two "grand price winners" were given a trip to Mountain View to visit the 
Google headquarters and meet with other GCi price winners.
</p>
<p>
You can see the results on the
<a href="http://wiki.netbsd.org/projects/code-in_2012/">corresponding wiki page</a>
</p>
<p>
There were 89 finished tasks, ranging from research tasks (document how other 
projects manage their documentation), creating howtos, trying out software on 
NetBSD, writing code (ATF tests and Markdown converters and more), writing 
manpages and documentation, fixing bugs and converting documentation from the 
website to the wiki.
</p>
<p>
Overall, it was a nice experience for NetBSD. On the one hand, some real work 
was done (for many of them, integration is still pending). On the other hand, it 
was a stressful time for the NetBSD mentors supervising the students and helping 
them on their tasks. Especially, we had to learn many lessons (you will find 
them on the wiki page for GCi 2012), but next time, we will do much better.
We will try to apply again next year, but we will need a large bunch of new 
possible tasks to be chosen again.
</p>
<p>
So if you think you have a task which doesn't require great prior knowledge, and 
is solvable within two hours by an experienced developer, but also by a 13-18 
year old within finite time, feel free to contact us with an outline, or write 
it directly to the <a href="http://wiki.netbsd.org/projects/code-in/">wiki page for Code-In</a>
in the NetBSD wiki.
</p>

   [<a href="http://blog.netbsd.org/tnf/entry/google_code_in_2012_2013#comments">1 comment</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/jdf_s_summer_of_code">jdf's Summer of Code project</a></h2><BR>
<div class="descr">June 27, 2013 posted by <i>Matthew Sporleder</I></div><BR>

  Julian Djamil Fagir wrote a blog post about <a href="http://www.komkon2.de/dokuwiki/doku.php?id=blog:participating_in_gsoc">his GSoC project</a><br />

<p>
<blockquote>As one of five, I've been chosen for participating in Google Summer Of Code (GSoC) this year for NetBSD. My project is to write a binary upgrade tool for NetBSD, optionally with a “live update” functionality.
</p>
<p>
Why an upgrade tool? – Yes, updating currently is easy. You download the set tarballs from a mirror, unpack the kernel, reboot, unpack the rest, reboot, and done. But this is an exhausting procedure, and you have to know that there are actually updates, and what they affect.
</p>
</blockquote>

<a href="http://www.komkon2.de/dokuwiki/doku.php?id=blog:participating_in_gsoc">read more</a><br />

 [<a href="http://blog.netbsd.org/tnf/entry/jdf_s_summer_of_code#comment-form">0 comments</a>]

</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/a_rump_kernel_hypervisor_for">A Rump Kernel Hypervisor for the Linux Kernel</a></h2><BR>
<div class="descr">April 23, 2013 posted by <i>Antti Kantee</I></div><BR>

  <p>
Ever since I realized that the
<a href="http://www.netbsd.org/docs/rump/">anykernel</a>
was the best way to construct a modern general purpose operating system
kernel, I have been performing experiments by running unmodified
NetBSD kernel drivers in <i>rump kernels</i> in various environments
(nb. here <i>driver</i> does not mean a hardware device driver, but
any driver like a file system driver or TCP driver).
These experiments have included <a
href="https://github.com/anttikantee/buildrump.sh">userspaces of various platforms</a>,
<a href="https://blog.netbsd.org/tnf/entry/netbsd_binary_kernel_modules_usable">binary kernel modules on Linux</a>
and
<a href="https://twitter.com/anttikantee/status/314153384548638720">others</a>, and
<a href="https://blog.netbsd.org/tnf/entry/kernel_drivers_compiled_to_javascript">compiling kernel drivers to javascript</a>
and running them natively in a web browser.  I have also claimed that
the anykernel allows harnessing drivers from a general purpose OS
onto more specialized embedded computing devices which are becoming the
new norm.  This is an attractive possibility because while writing drivers
is easy, making them handle all the abnormal conditions of the real world
is a time-consuming process.  Since the above-mentioned experiments
were done on POSIX platforms (yes, even the javascript one), the
experiments did not fully support the claim.  The most interesting,
decidedly non-POSIX platform I could think of for experimentation was
the Linux kernel.  Even though it had been several years since I last
worked in the Linux kernel, my hypothesis was that it would be easy
and fast to get unmodified NetBSD kernel drivers running in the Linux kernel as rump kernels.
</p>

<p>
A rump kernel runs on top of the rump kernel hypervisor.  The hypervisor
provides high level interfaces to host features, such as memory allocation
and thread creation.  In this case, the Linux kernel is the host.
In principle, there are three steps in getting a rump kernel to run in
a given environment.  In reality, I prefer a more iterative approach,
but the development can be divided into three steps all the same.

<ol>
  <li>implement generic rump kernel hypercalls, such as memory allocation,
      thread creation and synchronization</li>
  <li>figure out how to compile and run the rump kernel plus hypervisor
      in the target environment</li>
  <li>implement I/O related hypercalls for whatever I/O you plan to do</li>
</ol>
</p>

<p>
Getting basic functionality up and running was a relatively
straightforward process.  The only issue that required some thinking was
an application binary interface (ABI) mismatch.  I was testing on x86 where Linux kernel ABI uses <tt>-mregparm=3</tt>,
which means that function arguments are passed in registers where
possible.  NetBSD always passes arguments on the stack.  When two ABIs
collide, the code may run, but since function arguments passed
between the two ABIs result in garbage, eventually an error
will be hit perhaps in the form of accessing invalid memory.
The C code was easy enough to "fix" by applying the appropriate compiler
flags.  In addition to C code, a rump kernel uses a handful of assembly
routines from NetBSD, mostly pertaining to optimizations (e.g. <tt>ffs()</tt>),
but also to access the atomic memory operations of the platform.
After assembly routines had been handled, it was possible
to load a <a href="https://github.com/anttikantee/rumpuser-linuxkernel/blob/master/main.c">Linux kernel module which bootstraps a
rump kernel</a> in the Linux kernel and <a href="https://github.com/anttikantee/rumpuser-linuxkernel/blob/master/demo-fs.c">does some
file system operations</a> on the fictional <i>kernfs</i> file system.
A screenshot of the resulting dmesg output is shown below.
</p>

<!-- no idea why you can't upload images onto the blog platform anymore ... -->
<img src="http://ftp.netbsd.org/pub/NetBSD/misc/pooka/images/fs-demo.png" alt="fs demo screenshot"/>

<p>
It is one thing to execute a computation and an entirely different
thing to perform I/O.  To test I/O capabilities, I ran a rump kernel
providing a TCP/IP driver inside the Linux kernel.  For a networking
stack to be able to do anything sensible, the interface layer needs
to be able to shuffle packets.  The quickest way to implement
the hypercalls for packet shuffling was to use the same method
as a userspace virtual TCP/IP stack might use: read/write packets using
the tap device.
Some might say that doing this from inside the kernel is cheating, but
given that the alternative was to copypaste the tuntap driver and
edit it slightly, I call my approach constructive laziness.
</p>

<p>
The <a href="https://github.com/anttikantee/rumpuser-linuxkernel/blob/master/demo-net.c">demo itself</a> opens a TCP socket to port 80 on
vger.kernel.org (IP address 0x43b484d1 if you want to be really precise),
does a HTTP get for "/" and displays the last 500 bytes of the result.
TCP/IP is handled by the rump kernel, not by the Linux kernel.
Think of it as the Linux kernel having two alternative TCP/IP stacks.
Again, a screenshot of the resulting dmesg is shown below.  Note that
unlike in the first screenshot, there is no printout for the root file
system because the configuration used here does not include any file
system support.  Yes, you can ping <i>10.0.2.17</i>.
</p>

<img src="http://ftp.netbsd.org/pub/NetBSD/misc/pooka/images/netdemo.png" alt="net demo screenshot"/>

<p>
As hypothesized, a rump kernel hypervisor for the Linux kernel
was easy and straightforward to implement.  Furthermore, it could be done
without making any changes to the existing hypercall interface thereby
reinforcing the belief that unmodified NetBSD kernel drivers can run
on top of most any embedded firmwares just by implementing a light
hypervisor layer.
</p>

<p>
There were no challenges in the experiment, only annoyances.
As Linux does not support rump kernels, I had to revert back to
the archaic full OS approach to kernel development.  The drawbacks of
the full OS approach include for example suffering multi-second
reboot cycles during iterative development.  The other tangential issue
that I spent a disproportionately large amount of time with was thinking
about how releasing this code would affect existing NetBSD code due
to GPL involvement.  My conclusion was that this does not matter since
all code used by the current demo is open source anyway, and if someone
wants to use my code in a product, it is their problem, not mine.
</p>

<p>
For people interested in examining the implementation, I put the
source code for the hypervisor along with the test code in a git repo
<a href="https://github.com/anttikantee/rumpuser-linuxkernel">here</a>.
The repository also contains the demos linked from
this article.  The NetBSD kernel drivers I used are available from <a
href="http://ftp.netbsd.org/pub/NetBSD/">ftp.netbsd.org</a> or by
getting <a href="https://github.com/anttikantee/buildrump.sh">buildrump.sh</a>
and running <tt>./buildrump.sh checkout</tt>.
</p>


   [<a href="http://blog.netbsd.org/tnf/entry/a_rump_kernel_hypervisor_for#comments">2 comments</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/pointers_to_rpi_docs_and">pointers to rpi docs 2013Q1</a></h2><BR>
<div class="descr">March 23, 2013 posted by <i>Matthew Sporleder</I></div><BR>

  <p>
We get a lot of comments asking for tips on using the raspberry pi so I thought I would point out some docs:<br />

<a href="http://wiki.netbsd.org/ports/evbarm/raspberry_pi/">evbarm/rpi wiki docs</a><br />

An example of the rpi.img can be found here:<br />
<a href="http://nyftp.netbsd.org/pub/NetBSD-daily/HEAD/201303221130Z/evbarm/binary/gzimg/">http://nyftp.netbsd.org/pub/NetBSD-daily/HEAD/201303221130Z/evbarm/binary/gzimg/</a>  <i>notice the HEAD (NetBSD -current), datestamp, arch path for future reference</i><br />
</p>
<p>
There are also some concerns about building a kernel/img on your own.<br />
<a href="http://www.netbsd.org/docs/guide/en/chap-build.html">building NetBSD</a><br />
build.sh is one of the best features of NetBSD.  You can cross compile from almost any other unix-like system with very little difficulty.
</p>

   [<a href="http://blog.netbsd.org/tnf/entry/pointers_to_rpi_docs_and#comments">1 comment</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/netbsd_binary_kernel_modules_usable">NetBSD binary kernel modules usable on Linux in rump kernels</a></h2><BR>
<div class="descr">December 13, 2012 posted by <i>Antti Kantee</I></div><BR>

  <p>
Some years ago I <a href="http://blog.netbsd.org/tnf/entry/kernel_modules_autoload_from_host">wrote</a> about the possibility to load and use
standard NetBSD kernel modules in <a href="http://www.NetBSD.org/docs/rump/">rump kernels</a> on i386 and amd64.
With the recent developments in <a href="https://github.com/anttikantee/buildrump.sh">buildrump.sh</a> and the improved
ability to host rump kernels on non-NetBSD platforms, I decided to try
loading a binary NetBSD kernel module into a rump kernel compiled for
and running on Linux.  The hypothesis was that the NetBSD kernel modules
should just work since both the NetBSD kernel and Linux processes use
the ELF calling convention, and all platform details are abstracted by
the rump kernel hypercall layer.  Sure enough, after two small fixes to
the hypervisor I could mount and access a FFS file system on Linux by
using <tt>ffs.kmod</tt> as the driver.
</p>[<a class="readmore" href="http://blog.netbsd.org/tnf/entry/netbsd_binary_kernel_modules_usable">Read More</a>]

   [<a href="http://blog.netbsd.org/tnf/entry/netbsd_binary_kernel_modules_usable#comments">2 comments</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/gnats_mail_index_outage">gnats, mail-index outage</a></h2><BR>
<div class="descr">December 06, 2012 posted by <i>S.P.Zeidler</I></div><BR>

  The machine normally running www.NetBSD.org and also gnats and mail-index.NetBSD.org had a hardware problem.
It is now working again on a new chassis.


 [<a href="http://blog.netbsd.org/tnf/entry/gnats_mail_index_outage#comment-form">0 comments</a>]

</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/kernel_drivers_compiled_to_javascript">Kernel Drivers Compiled to Javascript and Run in Browser</a></h2><BR>
<div class="descr">November 07, 2012 posted by <i>Antti Kantee</I></div><BR>

  <p>
The unique anykernel capability of NetBSD allows the creation of
<a href="http://www.NetBSD.org/docs/rump">rump kernels</a>, which are
partially paravirtualized kernels running on top of a high-level
hypervisor.  This technology e.g. enables running the
<b>same</b> file system driver in the monolithic kernel or as a
microkernel style server in userspace.  POSIX-compatible
systems have been more or less supported as rump kernel hypervisors for
the past 5 years.  A long-time goal has been to extend hypervisor
support further, for example to embedded systems.  This would bring the
solid driverbase of NetBSD available to such systems with only the cost of
implementing the hypervisor.
</p>

<p>
To see how far things can go, last week I started toying with the
idea of using a javascript engine as a rump kernel hypervisor.  I was
planning to compile the NetBSD kernel sources into javascript and
manually implement the hypervisor.  After some
searching for a C->javascript compiler, I found
<a href="http://emscripten.org">emscripten</a>, which translates C into
javascript via LLVM bitcode.  Not only is the compiler itself extremely
mature, but there is also extensive support for the POSIX API.  This meant that
I could not only compile the kernel drivers to javascript with emscripten, I
could also compile the existing POSIX hypervisor and have it work.
</p>

<p>
The approach of compiling kernel drivers into javascript allows
them to be directly accessed from existing javascript code.  Yes,
I did add a <tt>sys/arch/javascript</tt> into the kernel source
tree.  This contrasts the approach taken by
<a href="http://bellard.org/jslinux/">another similar experiment</a>,
where an x86 Linux is run inside a x86 machine emulator running
in a javascript engine.
</p>

<p>
I have thrown together a small proof-of-concept demo of how to build a
web service with the capability to access file system images using
kernel file system drivers compiled to javascript.  I compiled a rump
kernel with support for the FFS, tmpfs and kernfs file systems.  This
rump kernel backend is tied to a lightweight web page which passes
requests from forms to the rump kernel and displays results.  When the
javascript is run, it downloads an FFS image (<tt>rump.data</tt>),
bootstraps a rump kernel, and mounts the FFS image r/o at <tt>/ffs</tt>.
The status can be further manipulated with interactive commands.
</p>

<p>
The demo is available
<a href="http://ftp.netbsd.org/pub/NetBSD/misc/pooka/rump.js/">here</a>.
I've tested it to work with Firefox and tested it to not work
with Internet Explorer.  YMMV with other browsers.  Note,
the javascript and the FFS image together are close to 5.5MB in
size, so the page may load for a few moments over a slow link --
javascript is not exactly compact and
whitespace removal was the only size reduction technique I used.
If you're interested in comparing the generated javascript with the <a
href="http://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/sys/">C
sources</a>, you can also look at the
<a href="http://ftp.netbsd.org/pub/NetBSD/misc/pooka/rump.js/rump.jsO0.txt">unoptimized version</a> (14MB).
</p>


   [<a href="http://blog.netbsd.org/tnf/entry/kernel_drivers_compiled_to_javascript#comments">16 comments</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/introducing_sysbuild_and_sysupgrade">Introducing sysbuild and sysupgrade</a></h2><BR>
<div class="descr">August 07, 2012 posted by <i>Julio Merino</I></div><BR>

  <p>If you are like me and do not like repeating manual tasks over and over again, you probably have written custom scripts to rebuild NetBSD from source and to upgrade your NetBSD installation to a new build. I have had such scripts for years, but they have always been very rudimentary, inflexible and unreliable. What's more: every NetBSD machine I have today has its own custom versions of these scripts, often with little incompatible tweaks to accomodate every installation.</p>

<p>I was now facing the time to rebuild my NetBSD development box (because its VM disk is running out of space), and the thought of having to reconfigure my environment to perform periodic NetBSD builds, and to have to continue using my deficient custom upgrade script gave me the energy to sit down and write decent versions of these two tools. The results of such efforts are sysbuild and sysupgrade, and their goal is to <i>trivialize</i> rebuilds and upgrades.</p>

<p><b>sysbuild</b>, currently available in <a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/sysutils/sysbuild/?only_with_tag=MAIN">pkgsrc/sysutils/sysbuild</a>, automates the process of fetching the NetBSD sources from a CVS repository and performing a build for one or more platforms. The process is defined by a configuration file that controls the parameters of the build, and building a new snapshot from scratch is as easy as issuing one parameter-less command. A companion <a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/sysutils/sysbuild-user/?only_with_tag=MAIN">sysbuild-user</a> package configures an unprivileged system user to perform nightly builds of NetBSD from cron, which is very convenient for developers tracking NetBSD-current. My other post "<a href="http://julipedia.meroh.net/2012/07/introducing-sysbuild-for-netbsd.html">Introducing sysbuild for NetBSD</a>" and the <tt>sysbuild(1)</tt> manual page provide more details.</p>

<p><b>sysupgrade</b>, currently available in <a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/sysutils/sysupgrade/?only_with_tag=MAIN">pkgsrc/sysutils/sysupgrade</a>, automates the process of bringing a NetBSD system up to date by using a collection of distribution sets (which can come from either sysbuild, your manual builds or a public FTP site). This tool does not have any upgrade knowledge of its own: it is "just" a script for the manual procedure of fetching the distribution sets, upgrading the kernel, unpacking the sets and upgrading <tt>/etc</tt> with the standard <tt>etcupdate</tt> and <tt>postinstall</tt>. My other post "<a href="http://julipedia.meroh.net/2012/08/introducing-sysupgrade.html">Introducing sysupgrade for NetBSD</a>" and the <tt>sysupgrade(8)</tt> manual page provide more details.</p>

<p>The tools are released under a typical permissive 3-clause BSD license. I have opted to place them in pkgsrc instead of the base system to give the tools some mileage and to make them immediately available to older releases and operating systems. However, my end goal for these tools (specially sysupgrade) is to end up being part of the NetBSD base system: I find it unfortunate that the base system does not provide a mechanism to upgrade itself to a newer release.</p>

<p><i>Enjoy the tools and please share your feedback!</i></p>

<p>... just keep in mind that these are fresh new code so obscure bugs may be lingering around. Hint: Run the included test suites to get some confidence in the implementation before running the tools.</p>

   [<a href="http://blog.netbsd.org/tnf/entry/introducing_sysbuild_and_sysupgrade#comments">1 comment</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/start_your_week_with_meeting">Start your week with meeting NetBSD</a></h2><BR>
<div class="descr">May 28, 2012 posted by <i>Mike M. Volokhov</I></div><BR>

  After weekend, on Monday, I usually warming myself up. It's always good to read an interesting article or meet eminent people to set a pitch for the week. This week such a reading was from Billy Toulas of the <a href="http://www.unixmen.com/">unixmen.com</a>, popular Unix/Linux online magazine who just <a href="http://www.unixmen.com/meet-martin-husemann-and-netbsd-interview/">interviewed Martin Husemann</a>.

<p>
Martin is one of those people with whom the NetBSD Project is strongly associated. He's former member of the NetBSD Board, and today is acting as sparc64 Portmaster and as part of NetBSD Security and Release Engineering teams. But don't be confused with all those loud names&nbsp;&mdash; Martin is very friendly man who fantastically can explain complex things.

<p>
The reading is interesting and long, and contains a number of amusing little know facts, so take a big popcorn pack, or start build.sh over NetBSD 6.0 BETA2 (just as I did) and <a href="http://www.unixmen.com/meet-martin-husemann-and-netbsd-interview/">enjoy the interview</a>.

 [<a href="http://blog.netbsd.org/tnf/entry/start_your_week_with_meeting#comment-form">0 comments</a>]

</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/new_netbsd_flyers_available">New NetBSD flyers available</a></h2><BR>
<div class="descr">March 18, 2012 posted by <i>Benny Siegert</I></div><BR>

  <p>For informing our peers about NetBSD, for distributing at a conference or meet-up, or simply as a concise introduction &ndash; new NetBSD flyers are now available at <a href="http://www.NetBSD.org/gallery/advocacy/#jdf-flyers">http://www.NetBSD.org/gallery/advocacy/</a>. They are made to be printed on A4 paper and folded twice. English and German versions are provided.</p>

<p>At the moment, there are three flyers: "What is NetBSD?" gives an overview about the project and the OS, while "Tips and Tricks for NetBSD newcomers" and "NetBSD for Newcomers &ndash; Switching from GNU/Linux" are more aimed at people who already know similar operating systems, particularly GNU/Linux, and want to know more about the differences between these systems and NetBSD.</p>

<p>We are very grateful to Julian Fagir, who provided these flyers to the project.</p>

   [<a href="http://blog.netbsd.org/tnf/entry/new_netbsd_flyers_available#comments">4 comments</a>]
 
</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/running_netbsd_on_the_lg">Running NetBSD on the LG-N2R1D NAS-family</a></h2><BR>
<div class="descr">December 15, 2011 posted by <i>Reinoud Zandijk</I></div><BR>

  
<p><p> Article about installing NetBSD on a small nas device  LG NAS-N2R1D. This requires some soldering and other black magic but otherwise pretty good example of NetBSD portability.</p></p>

[<a class="readmore" href="http://blog.netbsd.org/tnf/entry/running_netbsd_on_the_lg">Read More</a>]

 [<a href="http://blog.netbsd.org/tnf/entry/running_netbsd_on_the_lg#comment-form">0 comments</a>]

</p>


<p>&nbsp;</p>

            <h2><a href="http://blog.netbsd.org/tnf/entry/fossil_and_git_mirrors_of">Fossil and Git mirrors of pkgsrc and src</a></h2><BR>
<div class="descr">August 03, 2011 posted by <i>Jörg Sonnenberger</I></div><BR>

  <p>The NetBSD CVS repository has seen a lot of work over the recent months to clean up various historic artefacts. Together with the improvements in cvs2fossil and the Fossil->Git conversion, it is now possible to provide a precise, up-to-date conversion.</p>

<p>The Git repositories can be found on github, checkout <a href="https://github.com/jsonn/pkgsrc">pkgsrc</a> and <a href="https://github.com/jsonn/src">src</a>.</p>

<p>The Fossil repositories can be found at <a href="http://netbsd.sonnenberger.org">src</a> (<a href="http://src.aydogan.net">mirror</a>) and <a href="http://pkgsrc.sonnenberger.org">pkgsrc</a> (<a href="http://pkgsrc.aydogan.net">mirror</a>). The raw database as faster alternative to cloning can be found on <a href="http://ftp.NetBSD.org/pub/NetBSD/misc/repositories/fossil/">ftp.NetBSD.org</a>.</p>

<p>This repositories are synchronised with a normal latency of 2h. The only differences between a checkout from CVS and Fossil/Git are supposed to be related to historic checkouts of files pulled from a vendor branch. The implemented behaviour is consistent with the changes in the file. RCS IDs are all expanded using the same rules CVS follows.</p>

   [<a href="http://blog.netbsd.org/tnf/entry/fossil_and_git_mirrors_of#comments">3 comments</a>]
 
</p>


<p>&nbsp;</p>

    		  <div class="next-prev">
		  		                                 <a href="/tnf/category/General">Main</a>
                | <a href="/tnf/category/General?page=1">Next page</a> &raquo;
    		  		  </div>
		  				</div>
			</div>
			<div class="clearer"></div>
		</div>
		<div class="rowOfBoxes">
			<div id="footer">
				<span class="footfeed"><a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">Contact</a> |</span> <span class="footcopy"><a href="http://www.NetBSD.org/about/disclaimer.html">Disclaimer</a> | <span class="copyright">Copyright © 1994-2009 The NetBSD Foundation, Inc.</span> ALL RIGHTS RESERVED.<br />
				NetBSD<sup>®</sup> is a registered trademark of The NetBSD Foundation, Inc.</span>
			</div>
		</div>
	</body>
</html>

