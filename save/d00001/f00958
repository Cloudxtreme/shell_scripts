<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>talloc: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>talloc Documentation</h1><h3 class="version">2.0 </h3><p>talloc is a hierarchical, reference counted memory pool system with destructors. It is the core memory allocator used in Samba.</p>
<h2><a class="anchor" id="talloc_download">
Download</a></h2>
<p>You can download the latest releases of talloc from the <a href="http://samba.org/ftp/talloc" target="_blank">talloc directory</a> on the samba public source archive.</p>
<h2><a class="anchor" id="main-tutorial">
Tutorial</a></h2>
<p>You should start by reading <a class="el" href="libtalloc__tutorial.html">The Tutorial</a>, then reading the documentation of the interesting functions as you go.</p>
<h2><a class="anchor" id="talloc_bugs">
Discussion and bug reports</a></h2>
<p>talloc does not currently have its own mailing list or bug tracking system. For now, please use the <a href="https://lists.samba.org/mailman/listinfo/samba-technical" target="_blank">samba-technical</a> mailing list, and the <a href="http://bugzilla.samba.org/" target="_blank">Samba bugzilla</a> bug tracking system.</p>
<h2><a class="anchor" id="talloc_devel">
Development</a></h2>
<p>You can download the latest code either via git or rsync.</p>
<p>To fetch via git see the following guide:</p>
<p><a href="http://wiki.samba.org/index.php/Using_Git_for_Samba_Development" target="_blank">Using Git for Samba Development</a></p>
<p>Once you have cloned the tree switch to the master branch and cd into the lib/tevent directory.</p>
<p>To fetch via rsync use this command:</p>
<p>rsync -Pavz samba.org::ftp/unpacked/standalone_projects/lib/talloc .</p>
<h2><a class="anchor" id="talloc_preample">
Preamble</a></h2>
<p>talloc is a hierarchical, reference counted memory pool system with destructors.</p>
<p>Perhaps the biggest difference from other memory pool systems is that there is no distinction between a "talloc context" and a "talloc pointer". Any pointer returned from <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> is itself a valid talloc context. This means you can do this:</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>foo *X = <a class="code" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc</a>(mem_ctx, <span class="keyword">struct</span> foo);
      X-&gt;name = <a class="code" href="group__talloc__string.html#gaca866b920e3b876b00946027244cdd8f" title="Duplicate a string into a talloc chunk.">talloc_strdup</a>(X, <span class="stringliteral">&quot;foo&quot;</span>);
</pre></div><p>The pointer X-&gt;name would be a "child" of the talloc context "X" which is itself a child of mem_ctx. So if you do talloc_free(mem_ctx) then it is all destroyed, whereas if you do talloc_free(X) then just X and X-&gt;name are destroyed, and if you do talloc_free(X-&gt;name) then just the name element of X is destroyed.</p>
<p>If you think about this, then what this effectively gives you is an n-ary tree, where you can free any part of the tree with <a class="el" href="group__talloc.html#ga3de117af6571f568866ec311bcd75f86" title="Free a chunk of talloc memory.">talloc_free()</a>.</p>
<p>If you find this confusing, then run the testsuite to watch talloc in action. You may also like to add your own tests to testsuite.c to clarify how some particular situation is handled.</p>
<h2><a class="anchor" id="talloc_performance">
Performance</a></h2>
<p>All the additional features of <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> over malloc() do come at a price. We have a simple performance test in Samba4 that measures <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> versus malloc() performance, and it seems that <a class="el" href="group__talloc.html#ga69f0cbf5b2aed849a5b826f42e218bfa" title="Create a new talloc context.">talloc()</a> is about 4% slower than malloc() on my x86 Debian Linux box. For Samba, the great reduction in code complexity that we get by using talloc makes this worthwhile, especially as the total overhead of talloc/malloc in Samba is already quite small.</p>
<h2><a class="anchor" id="talloc_named">
Named blocks</a></h2>
<p>Every talloc chunk has a name that can be used as a dynamic type-checking system. If for some reason like a callback function you had to cast a "struct foo *" to a "void *" variable, later you can safely reassign the "void *" pointer to a "struct foo *" by using the <a class="el" href="group__talloc.html#ga1ee43e9ef59fc4edfce9a12b9cc54a63" title="Get a typed pointer out of a talloc pointer.">talloc_get_type()</a> or <a class="el" href="group__talloc.html#gaa12adf71d94abc4e1d80fb951808e374" title="Safely turn a void pointer into a typed pointer.">talloc_get_type_abort()</a> macros.</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>foo *X = <a class="code" href="group__talloc.html#gaa12adf71d94abc4e1d80fb951808e374" title="Safely turn a void pointer into a typed pointer.">talloc_get_type_abort</a>(ptr, <span class="keyword">struct</span> foo);
</pre></div><p>This will abort if "ptr" does not contain a pointer that has been created with talloc(mem_ctx, struct foo).</p>
<h2><a class="anchor" id="talloc_threading">
Multi-threading</a></h2>
<p>talloc itself does not deal with threads. It is thread-safe (assuming the underlying "malloc" is), as long as each thread uses different memory contexts.</p>
<p>If two threads uses the same context then they need to synchronize in order to be safe. In particular:</p>
<ul>
<li>when using <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits.">talloc_enable_leak_report()</a>, giving directly NULL as a parent context implicitly refers to a hidden "null context" global variable, so this should not be used in a multi-threaded environment without proper synchronization.</li>
<li>the context returned by <a class="el" href="group__talloc__ref.html#ga68f90d9a904bc2125b9bb60146f004de" title="Provide a talloc context that is freed at program exit.">talloc_autofree_context()</a> is also global so shouldn't be used by several threads simultaneously without synchronization. </li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
